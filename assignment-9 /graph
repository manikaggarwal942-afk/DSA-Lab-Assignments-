#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>
using namespace std;

// Graph using adjacency list
class Graph {
public:
    int V; // number of vertices
    vector<pair<int, int>>* adj; // for weighted edges: pair(neighbour, weight)

    Graph(int V) {
        this->V = V;
        adj = new vector<pair<int, int>>[V];
    }

    void addEdge(int u, int v, int w = 1, bool undirected = true) {
        adj[u].push_back(make_pair(v, w));
        if (undirected) {
            adj[v].push_back(make_pair(u, w));
        }
    }

    // 1. BFS
    void BFS(int start) {
        vector<bool> visited(V, false);
        queue<int> q;
        q.push(start);
        visited[start] = true;

        cout << "BFS: ";
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << u << " ";

            for (auto p : adj[u]) {
                int v = p.first;
                if (!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        cout << endl;
    }

    // 2. DFS (recursive)
    void DFSUtil(int u, vector<bool>& visited) {
        visited[u] = true;
        cout << u << " ";
        for (auto p : adj[u]) {
            int v = p.first;
            if (!visited[v]) {
                DFSUtil(v, visited);
            }
        }
    }

    void DFS(int start) {
        vector<bool> visited(V, false);
        cout << "DFS: ";
        DFSUtil(start, visited);
        cout << endl;
    }

    // 3a. Kruskal's MST
    struct Edge {
        int u, v, w;
    };

    int findParent(int u, vector<int>& parent) {
        if (parent[u] != u) parent[u] = findParent(parent[u], parent);
        return parent[u];
    }

    void unionSets(int u, int v, vector<int>& parent) {
        u = findParent(u, parent);
        v = findParent(v, parent);
        parent[u] = v;
    }

    void KruskalMST() {
        vector<Edge> edges;
        for (int u = 0; u < V; u++) {
            for (auto p : adj[u]) {
                int v = p.first, w = p.second;
                if (u < v) // avoid duplicates in undirected graph
                    edges.push_back({u, v, w});
            }
        }

        sort(edges.begin(), edges.end(), [](Edge a, Edge b) { return a.w < b.w; });

        vector<int> parent(V);
        for (int i = 0; i < V; i++) parent[i] = i;

        cout << "Kruskal MST edges:\n";
        for (auto e : edges) {
            if (findParent(e.u, parent) != findParent(e.v, parent)) {
                cout << e.u << " - " << e.v << " (weight " << e.w << ")\n";
                unionSets(e.u, e.v, parent);
            }
        }
    }

    // 3b. Prim's MST
    void PrimMST() {
        vector<int> key(V, INT_MAX);
        vector<bool> inMST(V, false);
        vector<int> parent(V, -1);
        key[0] = 0;

        for (int count = 0; count < V - 1; count++) {
            int u = -1;
            int minKey = INT_MAX;
            for (int v = 0; v < V; v++) {
                if (!inMST[v] && key[v] < minKey) {
                    minKey = key[v];
                    u = v;
                }
            }

            inMST[u] = true;

            for (auto p : adj[u]) {
                int v = p.first, w = p.second;
                if (!inMST[v] && w < key[v]) {
                    key[v] = w;
                    parent[v] = u;
                }
            }
        }

        cout << "Prim MST edges:\n";
        for (int i = 1; i < V; i++) {
            cout << parent[i] << " - " << i << " (weight " << key[i] << ")\n";
        }
    }

    // 4. Dijkstra's Shortest Path
    void Dijkstra(int start) {
        vector<int> dist(V, INT_MAX);
        vector<bool> visited(V, false);
        dist[start] = 0;

        for (int i = 0; i < V; i++) {
            int u = -1;
            int minDist = INT_MAX;
            for (int v = 0; v < V; v++) {
                if (!visited[v] && dist[v] < minDist) {
                    minDist = dist[v];
                    u = v;
                }
            }

            if (u == -1) break;
            visited[u] = true;

            for (auto p : adj[u]) {
                int v = p.first, w = p.second;
                if (!visited[v] && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }

        cout << "Dijkstra shortest distances from node " << start << ":\n";
        for (int i = 0; i < V; i++) {
            cout << i << ": " << dist[i] << endl;
        }
    }
};

int main() {
    int V, E;
    cout << "Enter number of vertices and edges: ";
    cin >> V >> E;

    Graph g(V);

    cout << "Enter edges (u v weight):\n";
    for (int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g.addEdge(u, v, w); // undirected
    }

    int start;
    cout << "Enter starting node for BFS/DFS/Dijkstra: ";
    cin >> start;

    g.BFS(start);
    g.DFS(start);

    g.KruskalMST();
    g.PrimMST();
    g.Dijkstra(start);

    return 0;
}
